/* ----------------------------------------------------------------------- */
/*                                                                         */
/*   Quartz Arc                                                            */
/*                                                                         */
/*   STM32 F411RE Nucleo 64                                                */
/*                                                                         */
/*   System: Drivers                                                       */
/*   Role: ADC Driver                                                      */
/*   Filename: QAD_ADC.cpp                                                 */
/*   Date: 16th November 2021                                              */
/*   Created By: Benjamin Rosser                                           */
/*                                                                         */
/*   This code is covered by Creative Commons CC-BY-NC-SA license          */
/*   (C) Copyright 2021 Benjamin Rosser                                    */
/*                                                                         */
/* ----------------------------------------------------------------------- */

//Includes
#include "QAD_ADC.hpp"


	//------------------------------------------
	//------------------------------------------
	//------------------------------------------


  //------------------------------
  //------------------------------
  //QAD_ADC Initialization Methods

//QAD_ADC::imp_init
//QAD_ADC Initialization Method
QA_Result QAD_ADC::imp_init(QAD_ADC_InitStruct& sInit) {
	m_eTimer           = sInit.eTimer;
	m_uTimer_Prescaler = sInit.uTimer_Prescaler;
	m_uTimer_Period    = sInit.uTimer_Period;

	if (!QAD_TimerMgr::getADC(m_eTimer)) {
		return QA_Error_PeriphNotSupported;
	}

  if (QAD_TimerMgr::getState(m_eTimer))
  	return QA_Error_PeriphBusy;

  QAD_TimerMgr::registerTimer(m_eTimer, QAD_Timer_InUse_ADC);
  QA_Result eRes = imp_periphInit(sInit);

  if (eRes)
  	QAD_TimerMgr::deregisterTimer(m_eTimer);
  return eRes;
}


//QAD_ADC::imp_deinit
//QAD_ADC Initialization Method
void QAD_ADC::imp_deinit(void) {
	if (!m_eInitState)
		return;

	imp_periphDeinit(DeinitFull);
	QAD_TimerMgr::deregisterTimer(m_eTimer);
}


  //-----------------------------------------
	//-----------------------------------------
	//QAD_ADC Peripheral Initialization Methods

//QAD_ADC::imp_periphInit
//QAD_ADC Peripheral Initialization Method
QA_Result QAD_ADC::imp_periphInit(QAD_ADC_InitStruct& sInit) {

	//Enable Timer Clock
	QAD_TimerMgr::enableClock(m_eTimer);

	//Initialize Timer
	m_sTIMHandle.Instance               = QAD_TimerMgr::getInstance(m_eTimer);
	m_sTIMHandle.Init.Prescaler         = m_uTimer_Prescaler;
	m_sTIMHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
	m_sTIMHandle.Init.Period            = m_uTimer_Period;
	m_sTIMHandle.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV1;
	m_sTIMHandle.Init.RepetitionCounter = 0x0;
	m_sTIMHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
	if (HAL_TIM_Base_Init(&m_sTIMHandle) != HAL_OK) {
		imp_periphDeinit(DeinitPartial);
		return QA_Fail;
	}

	//Setup Timer Trigger
	TIM_MasterConfigTypeDef MC_Init = {0};
	MC_Init.MasterOutputTrigger = TIM_TRGO_UPDATE;
	HAL_TIMEx_MasterConfigSynchronization(&m_sTIMHandle, &MC_Init);

	//Enable ADC Clock
	__HAL_RCC_ADC1_CLK_ENABLE();

	//Enable ADC IRQ
	HAL_NVIC_SetPriority(ADC_IRQn, QAD_IRQPRIORITY_ADC, 0x00);
	HAL_NVIC_EnableIRQ(ADC_IRQn);

	//Set States
	m_eInitState = QA_Initialized;
	m_eState     = QA_Inactive;

	//Return
	return QA_OK;
}


//QAD_ADC::imp_periphDeinit
//QAD_ADC Peripheral Initialization Method
void QAD_ADC::imp_periphDeinit(QAD_ADC::DeinitMode eMode) {

	if (m_eState) {
		imp_stop();
	}

	//Full Deinitialization
	if (eMode) {

		//Disable ADC IRQ
		HAL_NVIC_EnableIRQ(ADC_IRQn);

		//Disable ADC Clock
		__HAL_RCC_ADC1_CLK_DISABLE();

		//Deinit Timer
		HAL_TIM_Base_DeInit(&m_sTIMHandle);

	}

	//Disable Timer Clock
	QAD_TimerMgr::disableClock(m_eTimer);

	//Set States
	m_eInitState = QA_NotInitialized;
	m_eState     = QA_Inactive;

}


	//-----------------------
	//-----------------------
	//QAD_ADC Handler Methods

//QAD_ADC::imp_handler
//QAD_ADC Handler Method
void QAD_ADC::imp_handler(void) {
if (__HAL_ADC_GET_FLAG(&m_sADCHandle, ADC_FLAG_EOC)) {

	m_uData[m_uDataIdx] = m_sADCHandle.Instance->DR;
	if (m_uDataIdx >= (m_uChannelCount-1))
		m_uDataIdx = 0; else
		m_uDataIdx++;

	__HAL_ADC_CLEAR_FLAG(&m_sADCHandle, ADC_FLAG_EOC);
}
}








