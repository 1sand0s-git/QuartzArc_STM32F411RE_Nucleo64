/* ----------------------------------------------------------------------- */
/*                                                                         */
/*   Quartz Arc                                                            */
/*                                                                         */
/*   STM32 F411RE Nucleo 64                                                */
/*                                                                         */
/*   System: Drivers                                                       */
/*   Role: Timer Driver                                                    */
/*   Filename: QAD_Timer.hpp                                               */
/*   Date: 19th October 2021                                               */
/*   Created By: Benjamin Rosser                                           */
/*                                                                         */
/*   This code is covered by Creative Commons CC-BY-NC-SA license          */
/*   (C) Copyright 2021 Benjamin Rosser                                    */
/*                                                                         */
/* ----------------------------------------------------------------------- */

//Prevent Recursive Inclusion
#ifndef __QAD_TIMER_HPP_
#define __QAD_TIMER_HPP_

//Includes
#include "setup.hpp"

#include "QAD_TimerMgr.hpp"


	//------------------------------------------
	//------------------------------------------
	//------------------------------------------

//-------------
//QAD_TimerMode
//
//Used with QAD_Timer driver class to determine if update interrupt is to be triggered continuously, a set number of times of a single time.
enum QAD_TimerMode : uint8_t {
	QAD_TimerContinuous = 0,  //Update interrupt to be triggered continuously
	QAD_TimerMultiple,        //Update interrupt to be triggered a set number of times (based on counter target value)
	QAD_TimerSingle           //Update interrupt to be triggered a single time
};


//--------------------
//QAD_Timer_InitStruct
//
//This structure is used to be able to create the QAD_Timer driver class
typedef struct {

	QAD_Timer_Periph eTimer;           //Timer peripheral to be used

	QAD_TimerMode    eMode;            //Update interrupt mode. Member of QAD_TimerMode

	uint32_t         uPrescaler;       //Prescaler to be used for selected timer
	uint32_t         uPeriod;          //Counter period to be used for selected timer

	uint8_t          uIRQPriority;     //IRQ Priority for update interrupt (a value between 0 and 15)

	uint16_t         uCounterTarget;   //Counter target to be used when eMode is set to QAD_TimerMultiple

} QAD_Timer_InitStruct;


//---------
//QAD_Timer
//
//Driver class used for triggering timer update interrupts at regular intervals
class QAD_Timer {
private:

	//Deinitialization mode to be used by periphDeinit() method
	enum DeinitMode : uint8_t {
		DeinitPartial = 0,        //Only to be used for partial deinitialization up initialization failure in periphInit() method
		DeinitFull                //Used for full driver deinitialization when driver is in a fully initialize state
  };

	QAD_Timer_Periph  m_eTimer;
	TIM_HandleTypeDef m_sHandle;

	QAD_TimerMode     m_eMode;

	uint32_t          m_uPrescaler;
	uint32_t          m_uPeriod;

	uint8_t           m_uIRQPriority;

	QA_InitState      m_eInitState;

	QA_ActiveState    m_eState;

	IRQn_Type         m_eIRQ;

	QAD_IRQHandler_CallbackFunction m_pHandlerFunction;
	QAD_IRQHandler_CallbackClass*   m_pHandlerClass;

	uint16_t          m_uIRQCounterTarget;
	uint16_t          m_uIRQCounterValue;

public:

	QAD_Timer() = delete;
	QAD_Timer(QAD_Timer_InitStruct& sInit) :
		m_eTimer(sInit.eTimer),
		m_sHandle({0}),
		m_eMode(sInit.eMode),
		m_uPrescaler(sInit.uPrescaler),
		m_uPeriod(sInit.uPeriod),
		m_uIRQPriority(sInit.uIRQPriority),
		m_eInitState(QA_NotInitialized),
		m_eState(QA_Inactive),
		m_pHandlerFunction(NULL),
		m_pHandlerClass(NULL),
		m_uIRQCounterTarget(sInit.uCounterTarget),
		m_uIRQCounterValue(0) {}

	~QAD_Timer() {
		if (m_eState)
			stop();
		if (m_eInitState)
			deinit();
	}

	//Initialization Methods
	QA_Result init(void);
	void deinit(void);

	//IRQ Handler Methods
	void handler(void);

	//Control Methods
  void setHandlerFunction(QAD_IRQHandler_CallbackFunction pHandler);
  void setHandlerClass(QAD_IRQHandler_CallbackClass* pHandler);

  void setTimerMode(QAD_TimerMode eMode);
  QAD_TimerMode getTimerMode(void);

  void setIRQCounterTarget(uint16_t uTarget);
  uint16_t getIRQCounterTarget(void);

  uint16_t getIRQCounterValue(void);
  void clearIRQCounterValue(void);

  void start(void);
  void stop(void);

private:

  //Private Initialization Methods
  QA_Result periphInit(void);
  void periphDeinit(DeinitMode eMode);

};


//Prevent Recursive Inclusion
#endif /* __QAD_TIMER_HPP */









