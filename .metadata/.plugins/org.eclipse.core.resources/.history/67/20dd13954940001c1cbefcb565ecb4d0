/* ----------------------------------------------------------------------- */
/*                                                                         */
/*   Quartz Arc                                                            */
/*                                                                         */
/*   STM32 F411RE Nucleo 64                                                */
/*                                                                         */
/*   System: Drivers                                                       */
/*   Role: PWM Driver                                                      */
/*   Filename: QAD_PWM.hpp                                                 */
/*   Date: 1st November 2021                                               */
/*   Created By: Benjamin Rosser                                           */
/*                                                                         */
/*   This code is covered by Creative Commons CC-BY-NC-SA license          */
/*   (C) Copyright 2021 Benjamin Rosser                                    */
/*                                                                         */
/* ----------------------------------------------------------------------- */

//Prevent Recursive Inclusion
#ifndef __QAD_PWM_HPP_
#define __QAD_PWM_HPP_

//Includes
#include "setup.hpp"

#include "QAD_TimerMgr.hpp"


	//------------------------------------------
	//------------------------------------------
	//------------------------------------------


//NOTE: To determine how many PWM channels are supported by a specific timer peripheral, check the QAD_TimerMgr() constructor in QAD_TimerMgr.cpp, or
//alternatively check the reference documentation for the STM32F411RE device.


//---------------------
//QAD_PWM_CHANNEL_COUNT
//
//Used to define the maximum number of channels that can be supported by the QAD_PWM driver
#define QAD_PWM_CHANNEL_COUNT   4


//---------------
//QAD_PWM_Channel
//
//Enum used to select a specific PWM channel
//Note that not all timers support all four PWM channels
enum QAD_PWM_Channel : uint8_t {
	QAD_PWM_Channel_1 = 0,
	QAD_PWM_Channel_2,
	QAD_PWM_Channel_3,
	QAD_PWM_Channel_4
};


//--------------------------
//QAD_PWM_Channel_InitStruct
//
//This structure is used to store data specific to individual PWM channels
//This is used in both QAD_PWM_Init struct and within the QAD_PWM driver itself
typedef struct QAD_PWM_Channel_InitStruct {

	QA_ActiveState eActive;  //Stores whether this particular PWM channel is active. Member of QA_Active state defined in setup.hpp

	GPIO_TypeDef*  pGPIO;    //GPIO port to be used by this PWM channel
	uint16_t       uPin;     //Pin number to be used by this PWM channel
	uint8_t        uAF;      //Alternate function used to connect the GPIO pin to the respective timer peripheral


	//Assignment operator definition to allow easy copying of channel data from QAD_PWM_InitStruct to
	//members of m_sChannels array in QAD_PWM driver class
	QAD_PWM_Channel_InitStruct& operator=(const QAD_PWM_Channel_InitStruct& other) {
		eActive   = other.eActive;
		pGPIO     = other.pGPIO;
		uPin      = other.uPin;
		uAF       = other.uAF;
		return *this;
	}

} QAD_PWM_Channel_InitStruct;


//------------------
//QAD_PWM_InitStruct
//
//This structure is used to be able to create the QAD_PWM driver class
typedef struct {

	QAD_Timer_Periph  eTimer;       //Timer peripheral to be used. Member of QAD_Timer_Periph as defined in QAD_TimerMgr.hpp

	uint32_t          uPrescaler;   //Prescaler to be used for the selected timer
	uint32_t          uPeriod;      //Counter period to be used for the selected timer

	QAD_PWM_Channel_InitStruct sChannels[QAD_PWM_CHANNEL_COUNT];  //Data for individual PWM channels
	                                                              //Note that although four channels worth of init data can be supplied, the selected
	                                                              //timer peripheral may support less than four channels

} QAD_PWM_InitStruct;


	//------------------------------------------
	//------------------------------------------
	//------------------------------------------

//-------
//QAD_PWM
//
//Driver class used for generating PWM signals on between one and four channels
//Note that the number of available channels is determined by the number of channels supported by the selected timer peripheral
class QAD_PWM {
private:
  enum DeinitMode : uint8_t {
  	DeinitPartial = 0,
  	DeinitFull
  };

  QA_InitState       m_eInitState;
  QA_ActiveState     m_eState;

  QAD_Timer_Periph   m_eTimer;
  TIM_HandleTypeDef  m_sHandle;

  uint32_t           m_uPrescaler;
  uint32_t           m_uPeriod;

  QAD_PWM_Channel_InitStruct m_sChannels[QAD_PWM_CHANNEL_COUNT];

  uint32_t           m_uChannelSelect[QAD_PWM_CHANNEL_COUNT];

public:

	//Constructors/Destructors
  QAD_PWM() = delete;
  QAD_PWM(QAD_PWM_InitStruct& sInit) :
  	m_eInitState(QA_NotInitialized),
		m_eState(QA_Inactive),
		m_eTimer(sInit.eTimer),
		m_sHandle({0}),
		m_uPrescaler(sInit.uPrescaler),
		m_uPeriod(sInit.uPeriod) {

  	for (uint8_t i=0; i<QAD_PWM_CHANNEL_COUNT; i++) {
  		m_sChannels[i] = sInit.sChannels[i];
  	}

  	m_uChannelSelect[PWM_Channel_1] = TIM_CHANNEL_1;
  	m_uChannelSelect[PWM_Channel_2] = TIM_CHANNEL_2;
  	m_uChannelSelect[PWM_Channel_3] = TIM_CHANNEL_3;
  	m_uChannelSelect[PWM_Channel_4] = TIM_CHANNEL_4;
  }

  ~QAD_PWM() {
  	if (m_eState)
  		stop();
  	if (m_eInitState)
  		deinit();
  }

  //Initialization Methods
  QA_Result init(void);
  void deinit(void);

  //Control Methods
  void start(void);
  void stop(void);

  void setPWMVal(PWM_Channel eChannel, uint16_t uVal);

private:

  //Initialization Methods
  QA_Result periphInit(void);
  void periphDeinit(DeinitMode eMode);

};


//Prevent Recursive Inclusion
#endif /* __QAD_PWM_HPP_ */









